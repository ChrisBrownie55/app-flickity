<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="flickity-import.html">
<link rel="import" href="flickity-styles.html">

<!--
`<app-flickity>`
Flickity as a Polymer Element

### Flickity Doc's

[Options](http://flickity.metafizzy.co/options.html) | [Style](http://flickity.metafizzy.co/style.html) | [API](http://flickity.metafizzy.co/api.html)

### Styling

`<app-flickity>` provides the following custom properties and mixins
for styling:

Custom property | Description | Default
----------------|-------------|----------
`--app-flickity-cell` | Mixin applied to the cell with class of 'flickity-cell' | `{width: 66%; height: 200px; margin-right: 10px; background: #8C8; border-radius: 5px;}`

@demo demo/index.html
-->

<dom-module id="app-flickity">
  <template strip-whitespace>
    <style include="flickity-styles"></style>

    <content id="content"></content>

  </template>

  <script>
    Polymer({
      is: 'app-flickity',

      properties: {
        /**
         * <a target="_blank" href="http://flickity.metafizzy.co/options.html#cellselector">cellSelector</a> selector for cell elements. cellSelector is useful if you have other elements in your carousel elements that are not cells.
         *
         */
        cellSelector: {
          type: String,
          value: "[cell]"
        },
        /**
         * <a target="_blank" href="http://flickity.metafizzy.co/options.html#cellalign">cellSelector</a> Align cells within the carousel element.
         *
         */
        cellAlign: {
          type: String,
          value: "center"
        },
        /**
         * <a target="_blank" href="http://flickity.metafizzy.co/options.html#autoplay">autoPlay</a> Automatically advances to the next cell. <br><br> Auto-playing will pause when mouse is hovered over, and resume when mouse is hovered off. Auto-playing will stop when the carousel is clicked or a cell is selected.
         *
         */
        autoPlay: {
          type: Boolean,
          value: false
        },
        /**
         * <a target="_blank" href="http://flickity.metafizzy.co/options.html#freescroll">freeScroll</a> Enables content to be freely scrolled and flicked without aligning cells to an end position.
         *
         */
        freeScroll: {
          type: Boolean,
          value: false
        },
        /**
         * <a target="_blank" href="http://flickity.metafizzy.co/options.html#pagedots">pageDot</a>
         * Hides page dots.
         */
        hidePageDots: {
          type: Boolean,
          value: false
        },
        /**
         * <a target="_blank" href="http://flickity.metafizzy.co/options.html#wraparound">wrapAround</a>
         * At the end of cells, wrap-around to the other end for infinite scrolling.
         */
        wrapAround: {
          type: Boolean,
          value: false
        },
      },
      /**
       * Remove Flickity functionality completely. destroy will return the element back to its pre-initialized state.
       *
       */
      destroy: function() {
        if(this.flickity){
          this.flickity.destroy();
          this.flickity = null;
        }
      },
      /**
       * Re-collect all cell elements in flickity-slider.
       *
       */
      reload: function() {
        this.flickity.reloadCells();
      },
      /**
       * init flickity.
       *
       */
      init: function() {
        this.flickity = new Flickity(this, {
          autoPlay: this.autoPlay,
          cellSelector: this.cellSelector,
          cellAlign: this.cellAlign,
          cellAlign: this.cellAlign,
          freeScroll: this.freeScroll,
          pageDots: !this.hidePageDots,
          wrapAround: this.wrapAround
         });
      },
      /**
       * Select a slide.
       *
       */
      select: function(index) {
        if(this.flickity){
          this.flickity.select(index);
        }
      },

      attached: function() {
        this._checkIfTemplate();
        this._observer = Polymer.dom(this.$.content).observeNodes(function(info) {
          this._childrenChanged(info);
        }.bind(this));
      },

      _childrenChanged: function(info){
        //https://www.polymer-project.org/1.0/docs/devguide/local-dom#observe-nodes
        if(this.queryEffectiveChildren(this.cellSelector)){
          if(!this.flickity) {
            if(this.queryEffectiveChildren('template')){
              this.queryEffectiveChildren('template').render();
              this.init();
            }else{
              this.init();
            }
          }
        }
      },

      _checkIfTemplate: function(){
        if ( this.queryEffectiveChildren('template') ) {
          this.queryEffectiveChildren('template').addEventListener('dom-change', function() {
            if(this.flickity){
              if(this.flickity.getCellElements().length != this.queryAllEffectiveChildren(this.cellSelector)){
              this.destroy();
              this._childrenChanged();
              }
            }
          }.bind(this));
        }
      }

    });
  </script>
</dom-module>
